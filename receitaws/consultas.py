# AUTOGENERATED! DO NOT EDIT! File to edit: ..\consultas.ipynb.

# %% auto 0
__all__ = ['BASEURL', 'AMBIENTE', 'TIPO', 'CPF_SIMPLES', 'SEXO', 'TAMANHO', 'Requisicao', 'salvar_requisicao',
           'requisitar_em_lote']

# %% ..\consultas.ipynb 2
import re
from typing import Union, Iterable

import requests
import pandas as pd

from fastcore.basics import store_attr
from fastcore.foundation import L
from fastcore.parallel import parallel
from fastcore.xtras import Path
import typer
#from fastcore.script import call_parse, Param

BASEURL = "http://webservicesintranet{}.anatel.gov.br/receita/rest/"
AMBIENTE = {'ds', 'hm', 'su', 'pd'}
TIPO = {'cpf': "obterPessoaFisica", 'cnpj': "obterPessoaJuridica"}
CPF_SIMPLES = ('cpf', 'nome', 'nomeMae', 'dataNascimento', 'estrangeiro',
               'tituloEleitor', 'dataAtualizacao', 'dataRegistroAnatel', 
               'resultado', 'unidadeAdministrativaCodigo', 'anoObito', 'erro')
SEXO =  {1: 'Masculino', 2: 'Feminino', 9 : 'Não encontrado'}
TAMANHO = {11: 'cpf', 14: 'cnpj'}

# %% ..\consultas.ipynb 6
class Requisicao:
    def __init__(self, 
                 cpf_usuario: Union[str, int], # CPF do usuário requisitante
                 ambiente: str = 'ds', # Ambiente onde realizar a requisição: ds: desenvolvimento, hm: homologação, su: sustentação, pd: produção
                 origem: str = None, # Texto com identificação da requisição: e.g. "Teste"
                 cache: int = 36, # Tempo de expiração do cache em meses (Produção)
    ):
        """Classe para fazer requisições ao Web Service Receita - WS da Anatel, este encapsula o Infoconv da Receita Federal"""
        store_attr()
        assert isinstance(self.origem, str), "origem não pode ficar vazio e deve ser uma string de até 30 caracteres"
        self.origem = self.origem[:30]
        assert (ambiente := self.ambiente.lower()) in AMBIENTE, f"Ambiente inválido, escolha uma das opções {AMBIENTE}"
        if ambiente == 'pd':
            self.ambiente = ''
        self.cpf_usuario = ''.join(re.findall("\d", self.cpf_usuario))

    def formatar_url(self,
                  identificador, # Identificador da requisição: CPF ou CNPJ de acordo com o tipo
    )-> str: # Url formatada para a requisição GET REST
        """Recebe o identificador CPF|CNPJ e formata retorna a url formatada da requisição"""
        identificador = ''.join(re.findall("\d", identificador))
        if (tipo := len(identificador)) not in TAMANHO:
            raise ValueError("Query inválida, CPF possui 11 caracteres e CNPJ possui 14 caracteres")
        tipo = TAMANHO[tipo] #TODO: Validar refinadamente o CPF / CNPJ
        req_TIPO = TIPO[tipo]
        suffix = ''
        if self.cache is not None:
            try:
                cache = int(self.cache)
                assert cache >= 0, "Tempo de expiração do cache inválido, escolha um número inteiro maior que zero"
            except ValueError as e:
                raise ValueError("Valor inválido de expira_cache, escolha um número inteiro maior que zero") from e
            req_TIPO += 'IgnoraCacheAntigo'
            suffix = f'&mesesExpiraCache={cache}'

        return f'{BASEURL.format(self.ambiente)}{req_TIPO}?{tipo}={identificador}&cpfUsuario={self.cpf_usuario}{suffix}&origem={self.origem}'

    @staticmethod
    def nivelar_json(json_dict: dict, # Dicionário no formato json retornado pela requisição
    )-> dict: #Dicionário nivelado para formato tabular
        """Recebe um dicionário json com diferentes níveis e retorna os registros em um único nível"""
        d = {}
        for k,v in json_dict.items():
            if isinstance(v, list): 
                v = '|'.join(v)
            if isinstance(v, dict):
                d.update({f'{k}.{sk}': sv for sk, sv in v.items()})
                continue
            d[k] = v
        return {k:v.lstrip().rstrip() if isinstance(v, str) else v for k, v in d.items()}

    @staticmethod
    def _get_Requisicao(url: str, # Url formatada da requisição 
    )-> dict:
        """Efetua a requisição na url and retorna a resposta json"""
        r = requests.get(url)
        if r.status_code == 200 and r.headers['content-type'] == 'application/json':
            return Requisicao.nivelar_json(r.json())
        return {}

    def consultar(self, 
                 identificador: Union[str, int], # Identificador da requisição: CPF ou CNPJ de acordo com o tipo
    )-> dict: # Dicionário com o resultado da requisição
        """Efetua a requisição do identificador e retorna um dicionário"""
        return Requisicao._get_Requisicao(self.formatar_url(identificador))
    
    def consultar_em_lote(self, 
                      queries: Iterable[Union[str, int]], # Lista com os identificadores: CPF ou CNPJ
    )->Iterable[dict]: # Lisa com os dicionários resultantes das requisições                        
        return L(queries).map(self.consultar)
        

# %% ..\consultas.ipynb 23
def salvar_requisicao(results: Iterable, # Lista com o retorno das requisições
                 saida: str, # Nome do Arquivo de Saída
)->None:
    """Salva a lista de requisições `results` no arquivo `saida`"""
    df = pd.DataFrame(results)
    try:
        saida = Path(saida)
    except TypeError:
        saida = Path.cwd() / 'resultados.csv'

    match suffix := saida.suffix:
        case '.csv' | '.txt':
            df.to_csv(saida, index=False)
        case '.xlsx':
            df.to_excel(saida, index=False, engine='openpyxl')
        case '.json':
            df.to_json(saida)
        case '.md':
            df.to_markdown(saida, index=False)
        case '.html':
            df.to_html(saida, index=False)
        case _:
            df.to_csv(saida, index=False)

def requisitar_em_lote(filename: str, # Arquivo texto de entrada: 1 CPF | CNPJ por linha
                        cpf_usuario: str, # CPF do usuário requisitante
                        ambiente: str = 'ds', # Ambiente onde realizar a requisição: ds | hm | su | pd 
                        origem: str = None, # Texto com identificação da requisição: e.g. 'Teste'
                        cache: int = 36, # Tempo de expiração do cache em meses 
                        saida: str = None, # Arquivo de saída da requisição
)->None:
    """Lê o arquivo `filename` com um CPF | CPNJ por linha. Faz a requisição no `ambiente` do receita-ws e salva os resultados em `saida`"""
    conteudo = Path(filename).readlines()
    req = Requisicao(cpf_usuario, ambiente, origem, cache)
    resultado = req.consultar_em_lote(conteudo)
    salvar_requisicao(resultado, saida)
